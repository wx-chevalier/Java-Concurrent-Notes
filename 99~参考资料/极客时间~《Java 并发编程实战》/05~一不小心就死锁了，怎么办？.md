> DocId: 7Jk3YhsJ1BEXk4Z

# 一不小心就死锁了，怎么办？

在现实世界中，银行的转账操作是支持并发的，并且是真正并行进行的，银行的每个柜台都能够独立执行转账。如果我们能够在程序中模拟这种现实世界的并发转账操作，那么串行执行的问题就能得到解决。想象在古代，没有现代信息化手段，账户信息是以账本的形式存在的，每个账户对应一个账本，而这些账本都被统一存放在文件架上。当银行柜员执行转账操作时，他们需要从文件架上取下涉及转账的两个账本，然后进行操作。在这个过程中，柜员可能会遇到三种情况：

1. 文件架上同时有转出和转入的账本，柜员就可以直接取走这两个账本；
2. 如果文件架上只有其中一个账本，柜员会先取下现有的账本，然后等待另一个账本被其他柜员放回文件架；
3. 如果两个账本都不在文件架上，柜员就需要等待它们都被其他柜员送回来。

在编程实践中，如何实现类似古代银行柜员处理转账的流程？答案可以通过使用两把锁来模拟。我们为转出账户和转入账户各分配一把锁。在 transfer() 方法中，首先尝试获取转出账户 this 的锁（相当于拿到转出账本），随后尝试获取转入账户 target 的锁（相当于拿到转入账本）。只有当两把锁都成功获取时，我们才继续执行转账操作。这个过程可以用以下图形化的方式来表示。

![两个转账操作并行示意图](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/uPic/ra44p67PKjlF.png)

```java
class Account {
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 锁定转出账户
    synchronized(this) {
      // 锁定转入账户
      synchronized(target) {
        if (this.balance > amt) {
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  }
}
```

# 没有免费的午餐

与使用 Account.class 作为单一互斥锁相比，锁定的范围过于宽泛，而如果我们只锁定涉及转账的两个具体账户，锁定的范围就会小很多。这种锁我们在之前已经讨论过，被称为细粒度锁。采用细粒度锁能够提升程序的并行处理能力，是提升性能的一个关键策略。此时，你可能已经开始意识到，细粒度锁听起来如此简单有效，是否意味着需要付出一些额外的代价？在编写并发程序时，我们总是需要保持警惕。

确实，细粒度锁的使用并非没有成本，它可能带来的一个主要问题是死锁的风险。让我们先观察现实世界中的一个类似情形。设想客户向柜员张三请求进行一笔转账：从账户 A 向账户 B 转账 100 元。同时，另一位客户向柜员李四请求另一笔转账：从账户 B 向账户 A 转账 100 元。张三和李四都前往文件架取各自需要的账本。假设张三刚好拿到了 A 的账本，而李四拿到了 B 的账本。张三在拿到 A 的账本后，开始等待 B 的账本（此时在李四那里），李四在拿到 B 的账本后，开始等待 A 的账本（此时在张三那里）。他们需要等待多长时间呢？答案是他们会无限期地等待。因为张三不会归还 A 的账本，李四也不会归还 B 的账本。

![转账业务中的死等](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/uPic/4wMZRnMqHcL0.png)

死锁的一个比较专业的定义是：一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。死锁是如何在转账代码中发生的呢？假设线程 T1 正在执行从账户 A 到账户 B 的转账操作，即执行 账户 A.transfer(账户 B)；同时，线程 T2 正在执行从账户 B 到账户 A 的转账操作，即执行 账户 B.transfer(账户 A)。当 T1 和 T2 都完成第一步操作后，T1 已经锁定了账户 A（对于 T1，this 是账户 A），T2 已经锁定了账户 B（对于 T2，this 是账户 B）。接下来，在执行第二步操作时，T1 尝试锁定账户 B，但发现它已被 T2 锁定，因此 T1 进入等待状态；同样，T2 尝试锁定账户 A，但发现它已被 T1 锁定，于是 T2 也开始等待。这样，T1 和 T2 就会无限期地等待对方释放锁，这种情况就是所谓的死锁。

```java
class Account {
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 锁定转出账户
    synchronized(this){     ①
      // 锁定转入账户
      synchronized(target){ ②
        if (this.balance > amt) {
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  }
}
```

资源分配图是一个有向图，它能够展示资源与线程之间的状态关系。在这个图中，资源被表示为方形节点，而线程则用圆形节点表示；如果存在一条从资源节点指向线程节点的边，则意味着线程已经持有该资源；反之，如果边是从线程节点指向资源节点，则表示线程正在请求资源，但还未获得。当转账操作导致死锁时，资源分配图将呈现出一种特定的结构，形象地描绘了一种“各自为营，相互等待”的局面。
