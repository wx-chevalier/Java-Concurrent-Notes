# BIO，NIO 与 AIO

在《[Concurrent-Notes](https://github.com/wx-chevalir/Concurrent-Notes?q=)》中，我们讨论了 Unix 系统中的五种 IO 模型。除了信号驱动模型外，Java 都支持其他四种 IO 模型：

- Blocking IO（阻塞式 IO）：Java 最早提供的 IO 模型
- NIO（非阻塞 IO）：Java 后来引入的改进模型
- IO 多路复用：通过 NIO 中的 Reactor 模式实现
- 异步 IO：通过 AIO 中的 Proactor 模式实现

让我们先来了解传统的阻塞式 IO（blocking IO）。当我们使用 socket 读取数据时，如果调用 read 方法时数据还没准备好，当前线程就会在那里等待（阻塞），直到数据到达才能继续执行。这就像你在等外卖，如果外卖还没到，你就只能一直等在门口，什么事都做不了。

传统的网络服务为了处理并发请求，通常会采用多线程或线程池的设计模式。让我们用一个生活中的例子来理解:

- 想象你正在一家繁忙的餐厅。每当有新顾客（client 请求）到来，餐厅都会安排一名专门的服务员（线程）去服务。
- 这种一对一的服务模式确保了服务质量，因为每位顾客都有专属服务员，一个服务员忙碌不会影响其他服务员工作。
- 但是这种模式也带来了问题 - 如果餐厅客流量大，需要雇佣大量服务员，这会产生巨大的人力成本（系统资源消耗）。
- 为了优化成本，餐厅可以采用"服务员池"（线程池）的方式：维持固定数量的服务员，让他们轮流服务不同的顾客。这样可以避免频繁地招聘和解雇服务员（创建和销毁线程），从而节省开销。

这种基于多线程或线程池的模式在某些场景下表现很好：

- 比如快餐店这样的短连接场景 - 顾客来了，点餐，用餐，很快就离开。
- 但在咖啡厅这样的长连接场景下就显得很低效 - 顾客可能会在座位上待很久，大部分时间都在看书或聊天（建立连接但没有实际的 IO 操作），却要一直占用一名服务员的时间。

正是为了解决这种资源浪费的问题，Java 引入了更高效的 IO 模型 - NIO（New IO）模型。这个模型采用了 Reactor 模式，这也是 Reactive Programming（响应式编程）中的核心概念之一。

## BIO

让我们来了解 BIO（Blocking IO）这种在 JDK1.4 之前主流的编程方式。它的工作原理是这样的：

- 服务端会启动一个 ServerSocket 来监听网络请求
- 当客户端通过 Socket 发起连接请求时，ServerSocket 会为这个请求分配一个专门的线程
- 如果服务器当前没有可用的线程，客户端就只能等待（阻塞）或者被拒绝连接
- 一旦建立连接后，客户端和服务器之间的所有通信都是同步进行的

这种方式就像是一家传统餐厅：

- 每来一位顾客（客户端请求），餐厅都要安排一名专门的服务员（线程）
- 如果餐厅的服务员都在忙，新来的顾客就要等待或者被告知餐厅已满
- 服务员要一直陪着顾客，直到顾客用餐结束（请求处理完成）

下面是 BIO 的基本结构示意图：

![BIO 结构](https://s1.ax1x.com/2020/03/23/8o8kDS.md.png)

BIO 的主要特点是：

- 采用同步阻塞的工作方式
- 遵循"一个连接一个线程"的处理模式
- 如果连接建立后长时间不做事，会造成线程资源的浪费
- 可以通过使用线程池来改善性能
- 适合连接数量较少且稳定的系统
- 对服务器的资源要求较高
- 并发能力受限
- 是 JDK1.4 之前唯一的选择
- 代码逻辑直观，容易理解和维护

下图展示了使用线程池优化后的 BIO 模型：

![多线程下的 BIO 模型](https://s1.ax1x.com/2020/03/23/8o8BDO.md.png)

## NIO

Unblocking IO（New IO）同步非阻塞的编程方式。NIO 本身是基于事件驱动思想来完成的，其主要想解决的是 BIO 的大并发问题，NIO 基于 Reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。

NIO 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。在 NIO 的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC 连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有 BIO 一样的问题。

![NIO 示例](https://s1.ax1x.com/2020/03/23/8T2Av6.png)

同步非阻塞，服务器实现模式为一个请求一个通道，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理。NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程复杂，JDK1.4 开始支持。

- Buffer: ByteBuffer,CharBuffer,ShortBuffer,IntBuffer,LongBuffer,FloatBuffer,DoubleBuffer。
- Channel: SocketChannel,ServerSocketChannel。
- Selector: Selector,AbstractSelector
- SelectionKey: OP_READ,OP_WRITE,OP_CONNECT,OP_ACCEPT

## AIO

Asynchronous IO（AIO）是一种异步非阻塞的编程方式。让我们用一个生活中的例子来理解：想象你在餐厅点餐，AIO 就像是你点完餐后可以自由地做其他事情（比如玩手机），等餐做好了服务员会主动通知你。

在具体实现上，AIO 与 NIO 有很大的不同：

- 在进行读写操作时，你只需要调用 API 提供的 read 或 write 方法
- 这些方法都是异步执行的，这意味着：
  - 读操作：当数据准备好时，操作系统会自动将数据放入你指定的缓冲区，然后通知你的程序
  - 写操作：当操作系统完成数据写入后，会主动通知你的程序
- 所有的 read/write 操作都是异步的，完成后会自动触发你设置的回调函数

在 JDK1.7 中，这个功能被称为 NIO.2，它在 java.nio.channels 包中新增了四种异步通道：

- AsynchronousSocketChannel
- AsynchronousServerSocketChannel
- AsynchronousFileChannel
- AsynchronousDatagramChannel

从服务器架构的角度来看，AIO 采用了"一个有效请求配一个线程"的模式。它的工作方式是：操作系统先处理客户端的 I/O 请求，完成后再通知服务器程序启动线程处理。这就像餐厅的厨师（操作系统）先把菜做好，然后告诉服务员（服务器线程）可以上菜了。

AIO 特别适合处理以下场景：

- 连接数量多
- 每个连接都需要较长时间的操作（比如图片上传下载的相册服务器）
- 需要充分利用操作系统的并发处理能力

虽然 AIO 的编程相对复杂，但它能够提供更好的性能。这项技术从 JDK7 开始得到支持。

# Links

- https://zhuanlan.zhihu.com/p/386745556 这是我看过对 bio，nio，aio 解释的最透彻的文章！！！
