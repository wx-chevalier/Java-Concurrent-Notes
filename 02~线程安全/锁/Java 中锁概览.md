# Java 中锁概览

在 Java 并发编程中，我们经常会遇到各种不同类型的锁，比如公平锁、乐观锁等。本文将详细介绍 Java 中各种锁的分类和特点。主要包括以下几类：

- 公平锁/非公平锁
- 可重入锁/不可重入锁
- 独享锁/共享锁
- 互斥锁/读写锁
- 乐观锁/悲观锁
- 分段锁
- 偏向锁/轻量级锁/重量级锁
- 自旋锁

需要注意的是，上述这些锁的分类方式是从不同角度出发的。有些是描述锁的状态特征，有些是描述锁的实现机制，还有些是描述锁的设计思想。让我们逐一了解这些锁的具体含义。

# 公平锁/非公平锁

- 公平锁：顾名思义，公平锁确保线程获取锁的顺序与它们请求锁的顺序完全一致。就像排队买票一样，先来先得。

- 非公平锁：与公平锁相反，非公平锁并不保证线程获取锁的顺序。后来的线程可能会比先到的线程更早获得锁，这可能导致某些线程长时间无法获取到锁（称为"饥饿"现象），或者出现优先级反转的情况。

在 Java 中，ReentrantLock 可以通过构造函数来选择是否使用公平锁，默认情况下使用的是非公平锁。这是因为非公平锁的性能（吞吐量）通常优于公平锁。而 Synchronized 关键字实现的锁则永远是非公平的，因为它并不是基于 AQS（AbstractQueuedSynchronizer）实现的，所以也就无法像 ReentrantLock 那样支持公平性的选择。

# 可重入锁/不可重入锁

## 可重入锁

广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者 class），这样的锁就叫做可重入锁。ReentrantLock 和 synchronized 都是可重入锁。

```java
synchronized void setA() throws Exception {
    Thread sLeep(1000)
    setB();
}

synchronized void setB() throws Exception{
    Thread.sleep(1000)
}
```

上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB 可能不会被当前线程执行，可能造成死锁。

## 不可重入锁

不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁。看到一个经典的讲解，使用自旋锁来模拟一个不可重入锁，代码如下：

![使用自旋锁模拟不可重入](https://assets.ng-tech.icu/superbed/2021/07/18/60f391195132923bf864a42a.jpg)

代码也比较简单，使用原子引用来存放线程，同一线程两次调用 lock() 方法，如果不执行 unlock() 释放锁的话，第二次调用自旋的时候就会产生死锁，这个锁就不是可重入的，而实际上同一个线程不必每次都去释放锁再来获取锁，这样的调度切换是很耗资源的。

![修改为可重入锁方案](https://assets.ng-tech.icu/superbed/2021/07/18/60f391965132923bf8681369.jpg)

在执行每次操作之前，判断当前锁持有者是否是当前对象，采用 state 计数，不用每次去释放锁。ReentrantLock 中可重入锁（非公平）实现如下：

![ReentrantLock 实现](https://assets.ng-tech.icu/superbed/2021/07/18/60f391e85132923bf86a4fa3.jpg)

在 AQS 中维护了一个 private volatile int state 来计数重入次数，避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁。

# 独享锁/共享锁

独享锁和共享锁在你去读 C.U.T 包下的 ReeReentrantLock 和 ReentrantReadWriteLock 你就会发现，它俩一个是独享一个是共享锁。

- 独享锁: 该锁每一次只能被一个线程所持有。
- 共享锁: 该锁可被多个线程共有，典型的就是 ReentrantReadWriteLock 里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。

另外读锁的共享可保证并发读是非常高效的，但是读写和写写，写读都是互斥的。独享锁与共享锁也是通过 AQS 来实现的，通过实现不同的方法，来实现独享或者共享。对于 Synchronized 而言，当然是独享锁。

# 互斥锁/读写锁

## 互斥锁

在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。

如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被编程就绪状态，第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。在这种方式下，只有一个线程能够访问被互斥锁保护的资源

## 读写锁

读写锁是一种特殊的锁机制，它同时具备互斥锁和共享锁的特性：

- 读操作(read)采用共享模式 - 多个线程可以同时读取数据
- 写操作(write)采用互斥模式 - 只允许一个线程写入数据

读写锁在 Java 中通过 ReadWriteLock 接口实现，它维护了三种状态:

- 读锁定状态 - 允许多个线程同时获得读锁
- 写锁定状态 - 仅允许一个线程获得写锁
- 无锁状态 - 没有任何线程持有锁

读写锁的工作机制如下:

- 当一个线程获取写锁时:
  - 其他线程无法获取读锁或写锁
  - 必须等待写锁释放
- 当一个或多个线程获取读锁时:
  - 其他线程可以继续获取读锁
  - 但不能获取写锁
  - 必须等所有读锁都释放
- 为了防止写线程饿死:
  - 当有写线程在等待时
  - 新来的读线程会被阻塞
  - 直到写线程完成写操作

这种机制特别适合于读多写少的场景，可以显著提升系统的并发性能。例如缓存系统、配置信息等读取频繁但很少修改的场景。

# 乐观锁/悲观锁

## 悲观锁

悲观锁采用"先防范"的思想，它假设在并发环境下，数据随时都可能被其他线程修改。因此，在访问共享数据之前，悲观锁会先对数据进行加锁操作。具有以下特点：

- 任何线程想要访问数据，都必须先获得锁
- 其他线程必须等待，直到当前持有锁的线程释放锁
- 获得锁的线程可以独占地使用共享资源
- 用完资源后，线程会释放锁，让其他线程有机会获取

实际应用：

- 在关系型数据库中广泛使用，如 MySQL 的行锁、表锁
- Java 中的 synchronized 关键字和 ReentrantLock 类都是悲观锁的典型实现

## 乐观锁

乐观锁采用"先信任，后检查"的思想，它假设并发访问的冲突概率较低。具有以下特点：

- 不会在读取数据时加锁
- 在数据更新时才会检查是否有其他线程修改过数据
- 通常使用版本号或时间戳来检测数据是否被修改
- 如果检测到冲突，会重试操作而不是阻塞等待

实现机制：

- 版本号机制：在数据中维护一个版本号，每次更新数据时版本号加 1
- CAS(Compare-And-Swap)算法：原子性地比较并更新数据

应用场景：

- 特别适合读多写少的场景
- Java 中的 java.util.concurrent.atomic 包中的原子类使用了 CAS 实现
- 数据库的乐观锁机制，如通过 WHERE 条件检查版本号

# 分段锁

分段锁不是一种具体的锁实现，而是一种锁的设计思想。它的核心理念是将要锁定的数据分成多个独立的部分，每部分分别使用一把锁来保护。这样，当多个线程访问不同部分的数据时，它们就不会相互干扰。

以 ConcurrentHashMap 为例，它就是使用分段锁来实现高效的并发操作。这种设计显著提升了并发程序的性能，主要通过以下方式：

- 避免了所有线程争抢同一把锁的情况
- 减少了线程之间的竞争
- 提高了程序的可伸缩性

在并发编程中，如果使用传统的独占锁（一次只允许一个线程访问），会导致以下问题：

- 所有操作都必须串行执行，降低性能
- 频繁的线程上下文切换，增加系统开销
- 降低程序的可伸缩性

为了减少锁竞争带来的性能问题，我们通常可以采用以下策略：

- 尽可能缩短持有锁的时间
- 减少获取锁的次数
- 采用更细粒度的锁设计，允许更高的并发访问

分段锁就是这些策略中的一个典型应用。它的工作原理是：

- 将数据分成多个独立的段
- 每个段配备一个独立的锁
- 不同的线程可以同时访问不同的数据段
- 只有访问同一个数据段的线程才会产生锁竞争

让我们通过 ConcurrentHashMap 的实现来具体理解分段锁：

- 它内部使用了一个包含 16 个锁的数组
- 每个锁负责保护整个哈希表中 1/16 的数据桶
- 当一个线程要访问第 N 个数据桶时，它需要获取第(N mod 16)个锁
- 如果哈希算法设计合理，数据会均匀分布，这样就能将锁竞争程度降低到原来的 1/16
- 这种设计使得 ConcurrentHashMap 能够同时支持多达 16 个线程并发写入操作

这种分段锁的设计特别适合那些可以将数据自然分段，且各个数据段之间相对独立的场景。它能在保证线程安全的同时，显著提升并发性能。

# 偏向锁/轻量级锁/重量级锁

锁的状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。锁的状态是通过对象监视器在对象头中的字段来表明的。四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。这四种状态都不是 Java 语言中的锁，而是 Jvm 为了提高锁的获取与释放效率而做的优化(使用 synchronized 时)。

- 偏向锁：偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
- 轻量级：轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- 重量级锁：重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

# 自旋锁

在了解自旋锁之前，我们需要知道它与 CAS 算法的关系。CAS 算法是乐观锁的一种具体实现方式，而自旋锁则是 CAS 算法中的一个重要概念。

## CAS 与自旋锁实现

CAS（Compare and Swap，比较并交换）是一种著名的无锁算法。所谓无锁编程，是指在不使用传统锁机制的情况下，实现多个线程之间的数据同步。由于这种方式不会导致线程阻塞，因此也被称为非阻塞同步（Non-blocking Synchronization）。

CAS 算法在执行过程中会用到三个重要的值：

- 内存中的实际值 V
- 预期的比较值 A
- 准备写入的新值 B

CAS 的工作原理是：当我们想要更新一个变量时，会先检查内存中的实际值 V 是否与预期值 A 相等。如果相等，就将新值 B 写入内存；如果不相等，就说明其他线程修改了这个值，本次更新失败。在失败的情况下，CAS 通常会采用自旋的方式，也就是不断重试，直到更新成功为止。

自旋锁（spinlock）是一种特殊的锁机制。当一个线程试图获取已经被其他线程持有的自旋锁时，它不会像传统锁那样进入休眠状态，而是会一直循环检查锁是否已经被释放。这就像是在"原地打转"，这也是"自旋"这个名字的由来。

自旋锁和互斥锁都是为了保护共享资源，确保在同一时刻只有一个线程能够访问被保护的资源。它们的主要区别在于处理等待的方式：

- 互斥锁：当锁被占用时，其他线程会进入休眠状态
- 自旋锁：当锁被占用时，其他线程会持续检查锁的状态，保持运行状态

下面是一个 Java 中实现自旋锁的示例：

![自旋锁实现](https://assets.ng-tech.icu/superbed/2021/07/18/60f393a55132923bf876d2e0.jpg)

## 自旋锁优劣

自旋锁存在的问题如下：

- 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗 CPU。使用不当会造成 CPU 使用率极高。
- 上面 Java 实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。

自旋锁的优点如下：

- 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是 active 的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快
- 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。（线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）
