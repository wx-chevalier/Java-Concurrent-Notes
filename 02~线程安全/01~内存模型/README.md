# Java 内存模型（Java Memory Model, JMM）

## 概述

Java 内存模型（JMM）是一个规范，它定义了 Java 程序中各个变量（线程共享变量）的访问规则，以及在 JVM 中将变量存储到内存和从内存中读取变量这样的底层细节。

![Java 内存模型](https://assets.ng-tech.icu/item/20230417213538.png)

## 为什么需要内存模型

现代计算机系统中，CPU 处理器的运算速度和内存的访问速度差距较大，通常有数个数量级的差异。为了解决这个问题，计算机系统在 CPU 和主内存之间引入了高速缓存：

![Java 工作内存与 CPU 高速缓存](https://s3.ax1x.com/2021/01/28/y9e6JI.png)

## JMM 的核心概念

Java 内存模型规定：

- 所有变量都存储在主内存（Main Memory）中
- 每个线程都有自己的工作内存（Working Memory）
- 线程不能直接操作主内存中的变量，而是必须先将变量从主内存加载到工作内存中
- 线程对变量的所有操作都必须在工作内存中进行

## happens-before 原则

happens-before 是 JMM 中非常重要的概念，它定义了操作之间的内存可见性。如果一个操作 A happens-before 另一个操作 B，那么 A 操作的结果对 B 操作是可见的。主要规则包括：

1. **程序次序规则**：单线程内，按照程序代码顺序执行
2. **管程锁定规则**：解锁操作 happens-before 后续的加锁操作
3. **volatile 变量规则**：volatile 变量的写操作 happens-before 后续的读操作
4. **线程启动规则**：线程的 start() 方法 happens-before 该线程的所有操作
5. **线程终止规则**：线程的所有操作 happens-before 线程的终止检测
6. **对象终结规则**：对象的构造函数执行结束 happens-before finalize() 方法

需要注意的是，虽然 JVM 可能会对指令进行重排序，但是它会保证在单线程中执行结果的正确性。重排序只会针对不存在数据依赖性的指令进行。

## JMM 的发展

Java 内存模型在 1995 年首次提出，主要目标是解决不同硬件平台和操作系统上的线程同步问题。在 Java 5 之前，JMM 存在诸多问题，例如：

- 线程间的可见性问题
- 指令重排序导致的异常行为

Java 5 对 JMM 进行了重大修订，通过更严格的规范和新的同步机制（如 volatile 的增强语义），显著改善了并发编程的可靠性。
